% !TEX root = SegwayDoku.tex
\renewcommand{\autoren}{Stephan Morongowski}
\newpage
\section{Navigation}
\subsection{Sensorik}
Zur Verfügung stehen folgende Sensoren:
\begin{itemize}
\item Gyros in allen drei Raumachsen
\item Beschleunigungssensoren in allen drei Raumachsen
\item Inkrementalgeber der Räder
\item Ultraschallsensoren
\end{itemize}

\subsection{Bestimmung der Position im Welt-KS}

\subsubsection{Drehung um den Momentanpol}
\label{turningVelocityPole}
Zur Bestimmung der Position des Roboters in einem festen Koordinatensystem können die Inkrementalgeber der Antriebsmotoren benutzt werden.

\begin{figure}[h]  % [h] bedeutet, dass das Bild genau an dieser Stelle im Text erscheint
\centering\includegraphics[width=0.8\textwidth]{images/Kurvenkinematic.eps}
\caption{Rotation um den Momentanpol \newline (Quelle: eigene Darstellung, SM)}
\label{kurvenkinematik}
\end{figure}

Zur Ermittlung der aktuellen Position ist in Abbildung \ref{kurvenkinematik} die Kinematik einer Kurvenfahrt dargestellt, betrachtet für einen gedanklich sehr kleinen Zeitabschnitt. In diesem wird angenommen, dass die Geschwindigkeiten \(v_1\) und \(v_2\) beider Räder konstant bleiben. Dies sorgt für die Vereinfachung, dass der Roboter sich auf einer Kreisbahn um einen für die betrachtete Zeitspanne konstanten Momentanpol bewegt. Im Folgenden sind die durch den Inkrementalgeber erfassten Bogenlängen mit arc bezeichnet.
Es gilt:
\begin{flalign}
    % durch das & Zeichen werden alle Gleichungen an diesem Punkt ausgerichtet
	arc_{Rl} &  = \Delta\gamma\cdot r_{Rl}
	\label{eq:bogenmaß_1} \\
	arc_{Rr} & = \Delta\gamma\cdot r_{Rr}
	\label{eq:bogenmaß_2} \\
	r_{Rr} & = r_{Rl}  + l_a
	\label{eq:achsZuMomentanpol} \\
	\Delta arcs & = arc_{Rr} - arc_{Rl}
	\label{eq:arcsDef} \\
    r_S & = r_{Rr} - \frac{1}{2} l_a
	\label{eq:r_s}
\end{flalign}

Aus \eqref{eq:bogenmaß_1}, \eqref{eq:bogenmaß_2}, \eqref{eq:achsZuMomentanpol}, \eqref{eq:arcsDef} und \eqref{eq:r_s} folgen:
% hier keine Leerzeile machen, sonst wird der Abstand ganz groÃ
\begin{flalign}
    \Delta\gamma & = \frac{1}{l_a} \cdot \Delta arcs
	\label{eq:deltaPhi} \\
    r_S & = \frac{arc_{R2}}{\Delta\gamma} - \frac{1}{2} l_a
\end{flalign}

Timo Veit:
Die Verschiebungen aus den Geschwindigkeiten nenne ich erstmal $x_*$.
%In Simulink verwende ich erstmal die Geschwindigkeiten und integriere dann danach, um auf die richtige Einheit zu kommen. Da aus Geschwindigkeit mal Zeit wieder Strecke wird funktioniert das auch.

\begin{flalign}
	x_S &= \frac{x_2-x_1}{2}+x_1	\\
	r_S &=  \frac{l_a}{ \frac{x_2}{x_1}-1} +  \frac{l_a}{2}\\
	\Delta\gamma &= atan( \frac{x_S}{r_S})	
\end{flalign}
Durch Aufsummieren von \(\Delta\gamma\) nach jeder Auswertung der Inkrementalgeber kann somit ein ungefährer Absolutwinkel der Roboterachse zu einem festen KS berechnet werden.
\par\bigskip
Zur Bestimmung des Schwerpunktes in xy-Koordinaten wird die Verschiebung von
\(S_0\) zu \(S_1\) mit trigonometrischen Funktionen berechnet und anschließend aufsummiert. Es gilt:
\begin{flalign}
	\vec{S_1} = \vec{S_0} +
        \begin{pmatrix}
            -\sin{(\Delta \gamma)} \cdot r_S \cdot \sin{(\gamma_0)}
            - (r_S - \cos{(\Delta \gamma)} \cdot r_S) \cdot \cos{(\gamma_0}) \\
            \sin{(\Delta \gamma)} \cdot r_S \cdot \cos{(\gamma_0)}
            - (r_S - \cos{(\Delta \gamma)} \cdot r_S) \cdot \sin{(\gamma_0})
        \end{pmatrix}
	\label{eq:S_1}
\end{flalign}

bzw. vereinfacht:
\begin{flalign}
	\vec{S_1} = \vec{S_0} +
        \begin{pmatrix}
            r_S [\cos{(\gamma_0 + \Delta\gamma)} - \cos{\gamma_0}]  \\
            r_S [\sin{(\gamma_0 + \Delta\gamma)} - \sin{\gamma_0}]
        \end{pmatrix}
	\label{eq:S_1_easy}
\end{flalign}

\subsubsection{Vereinfachung}
\label{easyDeadReckoning}
Nachteilig an der in \ref{turningVelocityPole} beschriebenen Methode sind folgende zwei Punkte: Zum Einen muss eine Geradeausfahrt des Roboters als Spezialfall behandelt werden, da sonst eine Division durch Null erfolgen würde. Zum Zweiten finden die Berechnungen immer nahe einer Singularität statt. Für eine annähernde Geradeausfahrt wird $r_S$ sehr groß und $\Delta \gamma$ sehr klein, was zu großen Berechnungsfehlern führen kann.

Reagiert man nun auf jedes Pulssignal der Inkrementalgeber, wird eine der beiden Größen $arc_{Ri}$ zu Null und der Momentanpol liegt auf diesem Rad, welches sich annähernd nicht bewegt hat. So müssen nur vier Fälle bei der Summation der Lageänderungen beachtet werden:

\begin{itemize}
\item $R_l$ dreht sich vorwärts
\item $R_r$ dreht sich vorwärts
\item $R_l$ dreht sich rückwärts
\item $R_r$ dreht sich rückwärts
\end{itemize}

Für jeden dieser Fälle können nun die Positionsänderungen $\Delta\gamma$, $\Delta x$, $\Delta y$ im roboterfesten KS vorberechnet werden.
\begin{flalign}
    arc_{Ri} & = \frac{2\pi\cdot r_R}{n_{Enc}}  \\
	\Delta\gamma & = \frac{arc_{Ri}}{l_a}  \\
	\Delta x & = \frac{1}{2}l_a ( \cos{\Delta\gamma} - 1)  \\
	\Delta y & = \sin{\Delta\gamma}\frac{1}{2}l_a  
\end{flalign}
mit der Anzahl der Encoderimpulse pro Umdrehung $n_{Enc}$  \\ und dem Radumfang $r_R$. \\ \\
Bei jedem Impuls der Encoder werden nun die vorberechneten Positionsänderungen in das Welt-KS transformiert und aufsummiert.
\begin{flalign}
    Todo & = Todo
\end{flalign}
\newpage
